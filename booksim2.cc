// Hans Kasan
// CSNL-KAIST

#include "sst_config.h"
#include "booksim2.h"

// From BookSim's standalone main.cpp
#include <string>
#include <cstdlib>
#include <iostream>
#include <fstream>

#include <sstream>
#include "src/booksim.hpp"
#include "src/routefunc.hpp"
#include "src/traffic.hpp"
#include "src/random_utils.hpp"
#include "src/networks/network.hpp"
#include "src/injection.hpp"
#include "src/power/power_module.hpp"

using namespace SST;
using namespace SST::BookSim;
using namespace std;

// Global declarations from BookSim's standalone main.cpp
TrafficManager * trafficManager = NULL;

//uint64_t GetSimTime() {
int GetSimTime() {
    return trafficManager->getTime();
}

// BookSim's global variables
/* printing activity factor*/
bool gPrintActivity;

int gK; //radix
int gN; //dimension
int gC; //concentration

int gNodes;

//generate nocviewer trace
bool gTrace;

ostream * gWatchOut;

// Constructor
booksim2::booksim2(ComponentId_t id, Params& params) : Component(id)
{
    // Initialization
    BookSimConfig config;

    // Not supported
    /*
    if ( !ParseArgs( &config, argc, argv ) ) {
        cerr << "Usage: " << argv[0] << " configfile... [param=value...]" << endl;
        return 0;
    } 
    */

    // BEGIN: Override configuration with SST parameters
    bool found;
    std::string rf = params.find<string>("routing_function", "none", found); // Will return an error if the routing function is not specified
    config.Assign("routing_function", rf);

    std::string topo = params.find<string>("topology", "none", found); // Will return an error if the topology is not specified
    config.Assign("topology", topo);

    int k = params.find<int>("k", 0, found);
    config.Assign("k", k);

    int n = params.find<int>("n", 0, found);
    config.Assign("n", n);

    int c = params.find<int>("c", 0, found);
    config.Assign("c", c);

    int x = params.find<int>("x", 0, found);
    config.Assign("x", x);

    int y = params.find<int>("y", 0, found);
    config.Assign("y", y);

    int xr = params.find<int>("xr", 0, found);
    config.Assign("xr", xr);

    int yr = params.find<int>("yr", 0, found);
    config.Assign("yr", yr);

    int num_vcs = params.find<int>("num_vcs", 0, found);
    config.Assign("num_vcs", num_vcs);

    int vc_buf_size = params.find<int>("vc_buf_size", 16, found);
    config.Assign("vc_buf_size", vc_buf_size);

    int wait_for_tail_credit = params.find<int>("wait_for_tail_credit", 0, found);
    config.Assign("wait_for_tail_credit", wait_for_tail_credit);

    std::string priority = params.find<string>("priority", "none", found);
    config.Assign("priority", priority);

    std::string vc_alloc = params.find<string>("vc_alloc", "islip", found);
    config.Assign("vc_allocator", vc_alloc);

    std::string sw_alloc = params.find<string>("sw_alloc", "islip", found);
    config.Assign("sw_allocator", sw_alloc);

    int alloc_iters = params.find<int>("alloc_iters", 1, found);
    config.Assign("alloc_iters", alloc_iters);

    float internal_speedup = params.find<float>("internal_speedup", 1.0, found);
    config.Assign("internal_speedup", internal_speedup);

    int use_noc_latency = params.find<int>("use_noc_latency", 0, found);
    config.Assign("use_noc_latency", use_noc_latency);

    // END: Override configuration with SST parameters

    // Initialize based on our configuration
    InitializeRoutingMap( config );

    gPrintActivity = (config.GetInt("print_activity") > 0);
    gTrace = (config.GetInt("viewer_trace") > 0);
    
    string watch_out_file = config.GetStr( "watch_out" );
    if(watch_out_file == "") {
      gWatchOut = NULL;
    } else if(watch_out_file == "-") {
      gWatchOut = &cout;
    } else {
      gWatchOut = new ofstream(watch_out_file.c_str());
    }
    
    // Build network
    int subnets = config.GetInt("subnets");
    /*To include a new network, must register the network here
    *add an else if statement with the name of the network
    */
    _net.resize(subnets);
    for (int i = 0; i < subnets; ++i) {
      ostringstream name;
      name << "network_" << i;
      _net[i] = Network::New( config, name.str() );
    }

    // Create BookSimInterface instance that is derived from BookSimInterface_Base
    _num_motif_nodes = params.find<int>("num_motif_nodes", -1);
    _force_singleflit = params.find<int>("force_singleflit", 0, found);
    
    assert(_num_motif_nodes >= 0); // Must be a positive value

    _interface = (BookSimInterface_Base*)loadUserSubComponent<SST::BookSim::BookSimInterface_Base>
        ("booksim_interface", ComponentInfo::SHARE_PORTS, this, _num_motif_nodes);

    // Build traffic manager
    assert(trafficManager == NULL);
    trafficManager = TrafficManager::New( config, _net );

    // Configure link from the motif traffic (generated by Ember and Firefly) to our beloved BookSim
    //nic2booksim_link = configureLink("motif_node", new Event::Handler<booksim2>(this, &booksim2::handle_new_packets));

    // Make sure the links are successfully configured
    // If failed, check if the ports are connected in the input configuration file
    //sst_assert(nic2booksim_link, CALL_INFO, -1, "Error in %s: Link configuration failed\n", getName().c_str());

    // SST should not finish until BookSim is done
    //registerAsPrimaryComponent();
    //primaryComponentDoNotEndSim();

    // BookSim clock supplied from SST
    std::string booksim_clock = params.find<string>("booksim_clock", "1GHz", found);
    _clock_handler = new Clock::Handler<booksim2>(this, &booksim2::BabyStep);
    _booksim_tc = registerClock(booksim_clock, _clock_handler);

    // Clock is initially running, so don't need to wake BookSim up
    _is_request_alarm = false;

    // To keep the order of events as they were injected to the network
    _injected_events.resize(_num_motif_nodes);
}

booksim2::~booksim2()
{
  // Display stats
  //trafficManager->DisplayStats();
  trafficManager->_UpdateOverallStats();
  trafficManager->DisplayOverallStats();

  int subnets = config.GetInt("subnets");

  for (int i = 0; i < subnets; ++i){
    printf("Nodes: %d, subnets: %d\n", _net[i]->NumNodes(), subnets);
    delete _net[i];
  }

  delete trafficManager;
  trafficManager = NULL;
}

void booksim2::init(unsigned int phase)
{
  _interface->init(phase);
}

void booksim2::Inject(BookSimEvent* event)
{
  int src = event->getSrc();
  int dest = event->getDest();

  // Size of packets injected to BookSim
  int size;
  if (_force_singleflit)  size = 1;
  else                    size = event->getSizeInFlits();

  // Sanity checks
  assert((src >= 0) && (src < _num_motif_nodes));
  assert((dest >= 0) && (dest < _num_motif_nodes));
  assert(size >= 0);

  int pid = trafficManager->_InjectMotif(src, dest, size);

  // HANS: For debugging purpose, delete if not needed
  //if (((pid % 1024) == 0) || ((pid % 1024) == 1023))
  // if (src == 32)
    //printf("%d - BookSim inject with pid: %d from src: %d to dest: %d with size: %d at: %ld\n", GetSimTime(), pid, src, dest, size, getCurrentSimCycle());

  booksim_event_bundle event_bundle;
  event_bundle.event = event;
  event_bundle.ejected = false;

  _injected_events[dest].insert(make_pair(pid, event_bundle));

}

void booksim2::WakeBookSim()
{
    _is_request_alarm = false;
    Cycle_t next_cycle = reregisterClock( _booksim_tc, _clock_handler );
}

bool booksim2::IsRequestAlarm()
{
  return _is_request_alarm;
}


bool booksim2::BabyStep(Cycle_t cycle)
{
    trafficManager->_Step();

    // FOR DEBUGGING PURPOSE
    //printf("BabyStep at: %d\n", getCurrentSimCycle());

    // Raise the 'ejected' flag
    for (int iter_node = 0; iter_node < _num_motif_nodes; iter_node++){
      if (!trafficManager->IsRetiredPidEmpty(iter_node)){
        int pid = trafficManager->GetRetiredPid(iter_node);

        map<int, booksim_event_bundle>::iterator iter_map = _injected_events[iter_node].find(pid);
        BookSimEvent* event = iter_map->second.event;
        iter_map->second.ejected = true;
        assert(event->getDest() == iter_node);
      }
    }

    // Send event back to NIC following the order of arrival

    for (int iter_node = 0; iter_node < _num_motif_nodes; iter_node++){
      if (!_injected_events[iter_node].empty()){
        map<int, booksim_event_bundle>::iterator iter_map = _injected_events[iter_node].begin();

        while (iter_map->second.ejected){
          BookSimEvent* event = iter_map->second.event;
          assert(event->getDest() == iter_node);

          // Tell BookSimInterface to send this event back to NIC
          _interface->send(iter_node, event);

          // HANS: For debugging purpose, delete if not needed
          // printf("Retiring for node: %d at time: %ld\n", iter_node, getCurrentSimCycle());

          // Pop the entry if the event is sent back to the NIC
          _injected_events[iter_node].erase(iter_map);

          // HANS: For debugging purpose, delete if not needed
          //printf("Pop PID: %d at:%d\n", iter_map->first, GetSimTime());

          // Fetch the next head
          if (!_injected_events[iter_node].empty()){
            iter_map = _injected_events[iter_node].begin();
          } else {
            break; // Break the while loop, proceed with the outer for loop
          }
        }
      }
    }

    // Check if there is any outstanding packet in BookSim or events to be injected to the NIC
    if (trafficManager->_PacketsOutstanding() || !trafficManager->IsAllRetiredPidEmpty()){
      // Return false to indicate the clock handler should not be disabled
      _is_request_alarm = false;
      return false;
    } else {
      // Sanity check
      assert(_injected_events.empty());
      _is_request_alarm = true;
      return true;
    }
}