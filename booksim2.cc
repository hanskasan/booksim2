// Hans Kasan
// CSNL-KAIST

#include "sst_config.h"
#include "booksim2.h"

// From BookSim's standalone main.cpp
#include <string>
#include <cstdlib>
#include <iostream>
#include <fstream>

#include <sstream>
#include "src/booksim.hpp"
#include "src/routefunc.hpp"
#include "src/traffic.hpp"
#include "src/random_utils.hpp"
#include "src/networks/network.hpp"
#include "src/injection.hpp"
#include "src/power/power_module.hpp"

using namespace SST;
using namespace SST::BookSim;
using namespace std;

// Global declarations from BookSim's standalone main.cpp
TrafficManager * trafficManager = NULL;

int GetSimTime() {
    return trafficManager->getTime();
}

// BookSim's global variables
/* printing activity factor*/
bool gPrintActivity;

int gK; //radix
int gN; //dimension
int gC; //concentration

int gNodes;

//generate nocviewer trace
bool gTrace;

ostream * gWatchOut;

// Constructor
booksim2::booksim2(ComponentId_t id, Params& params) : Component(id)
{
    // Initialization
    BookSimConfig config;

    // Not supported
    /*
    if ( !ParseArgs( &config, argc, argv ) ) {
        cerr << "Usage: " << argv[0] << " configfile... [param=value...]" << endl;
        return 0;
    } 
    */

    // Override configuration with SST parameters
    bool found;
    std::string temp_rf = params.find<string>("routing_function", "none", found);
    config.Assign("routing_function", temp_rf);

    int k = params.find<int>("k", 0, found);
    config.Assign("k", k);

    int n = params.find<int>("n", 0, found);
    config.Assign("n", n);

    InitializeRoutingMap( config );

    gPrintActivity = (config.GetInt("print_activity") > 0);
    gTrace = (config.GetInt("viewer_trace") > 0);
    
    string watch_out_file = config.GetStr( "watch_out" );
    if(watch_out_file == "") {
      gWatchOut = NULL;
    } else if(watch_out_file == "-") {
      gWatchOut = &cout;
    } else {
      gWatchOut = new ofstream(watch_out_file.c_str());
    }
    
    // Build network
    int _subnets = config.GetInt("subnets");
    /*To include a new network, must register the network here
    *add an else if statement with the name of the network
    */
    _net.resize(_subnets);
    for (int i = 0; i < _subnets; ++i) {
      ostringstream name;
      name << "network_" << i;
      _net[i] = Network::New( config, name.str() );
    }

    // Create BookSimInterface instance that is derived from BookSimInterface_Base
    _num_motif_nodes = params.find<int>("num_motif_nodes", -1);
    
    assert(_num_motif_nodes >= 0); // Must be a positive value

    _interface = (BookSimInterface_Base*)loadUserSubComponent<SST::BookSim::BookSimInterface_Base>
        ("booksim_interface", ComponentInfo::SHARE_PORTS, this, _num_motif_nodes);

    // Build traffic manager
    assert(trafficManager == NULL);
    trafficManager = TrafficManager::New( config, _net );

    // Configure link from the motif traffic (generated by Ember and Firefly) to our beloved BookSim
    //nic2booksim_link = configureLink("motif_node", new Event::Handler<booksim2>(this, &booksim2::handle_new_packets));

    // Make sure the links are successfully configured
    // If failed, check if the ports are connected in the input configuration file
    //sst_assert(nic2booksim_link, CALL_INFO, -1, "Error in %s: Link configuration failed\n", getName().c_str());

    // SST should not finish until BookSim is done
    //registerAsPrimaryComponent();
    //primaryComponentDoNotEndSim();

    // BookSim clock supplied from SST
    std::string booksim_clock = params.find<string>("booksim_clock", "1GHz", found);
    _clock_handler = new Clock::Handler<booksim2>(this, &booksim2::BabyStep);
    _booksim_tc = registerClock(booksim_clock, _clock_handler);

    // Clock is initially running, so don't need to wake BookSim up
    _is_request_alarm = false;
}

booksim2::~booksim2()
{
  for (int i = 0; i < _subnets; ++i){
    delete _net[i];
  }

  delete trafficManager;
  trafficManager = NULL;
}

void booksim2::Inject(BookSimEvent* event)
{
  int src = event->getSrc();
  int dest = event->getDest();
  int size = event->getSizeInFlits();

  // Sanity checks
  assert((src >= 0) && (src < _num_motif_nodes));
  assert((dest >= 0) && (dest < _num_motif_nodes));
  assert(size >= 0);

  int pid = trafficManager->_InjectMotif(src, dest, size);

  _injected_events.insert(make_pair(pid, event));

  printf("BookSim inject with pid: %d at time: %ld\n", pid, getCurrentSimCycle());
}

void booksim2::WakeBookSim()
{
    _is_request_alarm = false;
    Cycle_t next_cycle = reregisterClock( _booksim_tc, _clock_handler );
}

bool booksim2::IsRequestAlarm()
{
  return _is_request_alarm;
}


bool booksim2::BabyStep(Cycle_t cycle)
{
    trafficManager->_Step();

    // FOR DEBUGGING PURPOSE
    //printf("BabyStep at: %d\n", getCurrentSimCycle());

    // Send event back to NIC
    for (int iter_node = 0; iter_node < _num_motif_nodes; iter_node++){
      if (!trafficManager->IsRetiredPidEmpty(iter_node)){
        int pid = trafficManager->GetRetiredPid(iter_node);

        map<int, BookSimEvent *>::iterator iter_map = _injected_events.find(pid);
        BookSimEvent* event = iter_map->second;
        assert(event->getDest() == iter_node);

        // Tell BookSimInterface to send this event back to NIC
        _interface->send(iter_node, event);

        _injected_events.erase(iter_map);
      }
    }

    // Check if there is any outstanding packet in BookSim or events to be injected to the NIC
    if (trafficManager->_PacketsOutstanding() || !trafficManager->IsAllRetiredPidEmpty()){
      // Return false to indicate the clock handler should not be disabled
      _is_request_alarm = false;
      return false;
    } else {
      // Sanity check
      assert(_injected_events.empty());

      _is_request_alarm = true;
      return true;
    }
}