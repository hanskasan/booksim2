// Hans Kasan
// CSNL-KAIST

#include "sst_config.h"
#include "booksim2.h"

// From BookSim's standalone main.cpp
#include <string>
#include <cstdlib>
#include <iostream>
#include <fstream>

#include <sstream>
#include "src/booksim.hpp"
#include "src/routefunc.hpp"
#include "src/traffic.hpp"
#include "src/random_utils.hpp"
#include "src/networks/network.hpp"
#include "src/injection.hpp"
#include "src/power/power_module.hpp"

using namespace SST;
using namespace SST::BookSim;
using namespace std;

// Global declarations from BookSim's standalone main.cpp
TrafficManager * trafficManager = NULL;

int GetSimTime() {
    return trafficManager->getTime();
}

// BookSim's global variables
/* printing activity factor*/
bool gPrintActivity;

int gK; //radix
int gN; //dimension
int gC; //concentration

int gNodes;

//generate nocviewer trace
bool gTrace;

ostream * gWatchOut;

// Constructor
booksim2::booksim2(ComponentId_t id, Params& params) : Component(id)
{
    // Initialization
    BookSimConfig config;

    // Not supported
    /*
    if ( !ParseArgs( &config, argc, argv ) ) {
        cerr << "Usage: " << argv[0] << " configfile... [param=value...]" << endl;
        return 0;
    } 
    */

    // Override configuration with SST parameters
    bool found;
    std::string temp_rf = params.find<string>("routing_function", "valiant", found); // Consider changing the default value to none
    config.Assign("routing_function", temp_rf);

    InitializeRoutingMap( config );

    gPrintActivity = (config.GetInt("print_activity") > 0);
    gTrace = (config.GetInt("viewer_trace") > 0);
    
    string watch_out_file = config.GetStr( "watch_out" );
    if(watch_out_file == "") {
      gWatchOut = NULL;
    } else if(watch_out_file == "-") {
      gWatchOut = &cout;
    } else {
      gWatchOut = new ofstream(watch_out_file.c_str());
    }
    
    // Build network
    int _subnets = config.GetInt("subnets");
    /*To include a new network, must register the network here
    *add an else if statement with the name of the network
    */
    _net.resize(_subnets);
    for (int i = 0; i < _subnets; ++i) {
      ostringstream name;
      name << "network_" << i;
      _net[i] = Network::New( config, name.str() );
    }

    // Create BookSimInterface instance that is derived from BookSimInterface_Base
    _num_motif_nodes = params.find<int>("num_motif_nodes", -1);
    
    assert(_num_motif_nodes > 0); // Must be a positive value

    _interface = (BookSimInterface_Base*)loadUserSubComponent<SST::BookSim::BookSimInterface_Base>
        ("booksim_interface", ComponentInfo::SHARE_NONE, this, _num_motif_nodes);

    // Build traffic manager
    assert(trafficManager == NULL);
    trafficManager = TrafficManager::New( config, _net );

    // Configure link from the motif traffic (generated by Ember and Firefly) to our beloved BookSim
    //nic2booksim_link = configureLink("motif_node", new Event::Handler<booksim2>(this, &booksim2::handle_new_packets));

    // Make sure the links are successfully configured
    // If failed, check if the ports are connected in the input configuration file
    //sst_assert(nic2booksim_link, CALL_INFO, -1, "Error in %s: Link configuration failed\n", getName().c_str());

    // SST should not finish until BookSim is done
    registerAsPrimaryComponent();
    primaryComponentDoNotEndSim();

    // BookSim clock supplied from SST
    std::string booksim_clock = params.find<string>("booksim_clock", "1GHz", found);
    clock_handler = new Clock::Handler<booksim2>(this, &booksim2::BabyStep);
    registerClock("1GHz", clock_handler);
}

booksim2::~booksim2()
{
  for (int i = 0; i < _subnets; ++i){
    delete _net[i];
  }

  delete trafficManager;
  trafficManager = NULL;
}

bool booksim2::BabyStep(Cycle_t cycle)
{
    trafficManager->_Step();

    if (GetSimTime() == 100){

      // Things to do at the end of the simulation
      for (int i = 0; i < _subnets; ++i) {
        ///Power analysis
        if(config.GetInt("sim_power") > 0){
          Power_Module pnet(_net[i], config);
          pnet.run();
        }
      }

      // Tell SST that it's OK to end the simulation
      primaryComponentOKToEndSim();
      return true;
    }

    // Return false to indicate the clock handler should not be disabled
    return false;
}